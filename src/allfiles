api.js



import axios from 'axios';
import tough from 'tough-cookie';
import fs from 'fs';


class YouTubeTranscriptApi {
    static async listTranscripts(videoId, proxies = null, cookies = null) {
        const client = axios.create();
        
        if (cookies) {
            const jar = await this.loadCookies(cookies);
            client.defaults.jar = jar;
            client.defaults.withCredentials = true;
        }

        if (proxies) {
            client.defaults.proxy = proxies;
        }

        // Placeholder for TranscriptListFetcher functionality
        // Assuming TranscriptListFetcher.fetch() returns a promise
        const transcriptListFetcher = new TranscriptListFetcher(client);
        return transcriptListFetcher.fetch(videoId);
    }

    static async getTranscripts(videoIds, languages = ['en'], continueAfterError = false, proxies = null, cookies = null, preserveFormatting = false) {
        if (!Array.isArray(videoIds)) {
            throw new Error('`video_ids` must be a list of strings');
        }

        const data = {};
        const unretrievableVideos = [];

        for (const videoId of videoIds) {
            try {
                data[videoId] = await this.getTranscript(videoId, languages, proxies, cookies, preserveFormatting);
            } catch (error) {
                if (!continueAfterError) {
                    throw error;
                }
                unretrievableVideos.push(videoId);
            }
        }

        return { data, unretrievableVideos };
    }

    static async getTranscript(videoId, languages = ['en'], proxies = null, cookies = null, preserveFormatting = false) {
        if (typeof videoId !== 'string') {
            throw new Error('`video_id` must be a string');
        }
        const transcriptList = await this.listTranscripts(videoId, proxies, cookies);
        return transcriptList.findTranscript(languages).fetch({ preserveFormatting });
    }

    static async loadCookies(cookiesPath) {
        const cookieJar = new tough.CookieJar();
        return new Promise((resolve, reject) => {
            fs.readFile(cookiesPath, 'utf8', (err, data) => {
                if (err) {
                    return reject(new CookiePathInvalid());
                }

                try {
                    cookieJar.setCookieSync(data, 'https://www.youtube.com');
                    resolve(cookieJar);
                } catch (e) {
                    reject(new CookiesInvalid());
                }
            });
        });
    }
}

// Placeholder for missing dependencies
class TranscriptListFetcher {
    constructor(client) {
        this.client = client;
    }

    fetch(videoId) {
        // Placeholder method
        return Promise.resolve({
            findTranscript: (languages) => ({
                fetch: ({ preserveFormatting }) => {
                    // Placeholder fetch implementation
                    return Promise.resolve([{
                        text: 'Example transcript text',
                        start: 0.0,
                        end: 10.0
                    }]);
                }
            })
        });
    }
}

class CookiePathInvalid extends Error {}
class CookiesInvalid extends Error {}

module.exports = YouTubeTranscriptApi;



cli.js



import { Command } from 'commander';
import axios from 'axios';
import tough from 'tough-cookie';
import fs from 'fs';
import { 
    fetchVideoHtml, 
    extractCaptionsJson, 
    buildTranscriptList, 
    findTranscript, 
    findGeneratedTranscript, 
    findManuallyCreatedTranscript 
} from './transcripts.js';
import {
    formatPretty, 
    formatJSON, 
    formatPlainText, 
    formatSRT, 
    formatWebVTT, 
    FormatterFactory 
} from './formatter.js';
import { watchURL } from './settings.js';

const ytScript = async () => {

    function parseArguments() {
        const program = new Command();

        program
            .name('yt-script')
            .description('Fetch YouTube video transcripts.')
            .argument('<video_ids...>', 'List of YouTube video IDs.')
            .option('--list-transcripts', 'List available languages for the given videos.')
            .option('--languages <languages...>', 'List of languages in descending priority', ['en'])
            .option('--format <format>', 'Output format', 'pretty')
            .option('--translate <language>', 'Language to translate the transcript to.')

        program.parse(process.argv);

        const options = program.opts();
        options.video_ids = program.args; // Extract video_ids from arguments
        return options;
    }

    async function fetchAndFormatTranscripts(options) {
        const { video_ids, listTranscripts, languages, excludeGenerated, excludeManuallyCreated, format, translate } = options;

        if (excludeGenerated && excludeManuallyCreated) {
            return '';
        }

        const proxies = (httpProxy || httpsProxy) ? { http: httpProxy, https: httpsProxy } : null;
        const cookiesData = cookies ? fs.readFileSync(cookies, 'utf8') : null;
        const transcripts = [];
        const exceptions = [];

        for (const videoId of video_ids) {
            try {
                const transcript = await fetchTranscript(videoId, proxies, cookiesData, languages, listTranscripts, excludeGenerated, excludeManuallyCreated, translate);
                transcripts.push(transcript);
            } catch (exception) {
                exceptions.push(exception);
            }
        }

        const formatter = FormatterFactory(format);
        return [...exceptions.map(e => e.toString()), transcripts.length ? formatter(transcripts) : ''].join('\n\n');
    }

    async function fetchTranscript(videoId, proxies, cookiesData, languages, listTranscripts, excludeGenerated, excludeManuallyCreated, translate) {
        const httpClient = axios.create({ proxy: proxies });
        httpClient.defaults.jar = new tough.CookieJar();

        if (cookiesData) {
            cookiesData.split('\n').forEach(cookie => {
                if (cookie.trim()) {
                    httpClient.defaults.jar.setCookieSync(cookie, 'https://www.youtube.com');
                }
            });
        }

        const html = await fetchVideoHtml(httpClient, videoId);
        const captionsJson = extractCaptionsJson(html, videoId);
        const transcriptList = buildTranscriptList(httpClient, videoId, captionsJson);

        if (listTranscripts) {
            return transcriptListToString(transcriptList);
        }

        let transcript;
        if (excludeGenerated) {
            transcript = findManuallyCreatedTranscript(transcriptList, languages);
        } else if (excludeManuallyCreated) {
            transcript = findGeneratedTranscript(transcriptList, languages);
        } else {
            transcript = findTranscript(transcriptList, languages);
        }

        if (translate) {
            transcript = await transcript.translate(translate);
        }

        return await transcript.fetch();
    }

    function transcriptListToString(transcriptList) {
        return `For this video (${transcriptList.videoId}) transcripts are available in the following languages:\n\n(MANUALLY CREATED)\n${getLanguageDescription(Object.values(transcriptList.manuallyCreatedTranscripts))}\n\n(GENERATED)\n${getLanguageDescription(Object.values(transcriptList.generatedTranscripts))}\n\n(TRANSLATION LANGUAGES)\n${getLanguageDescription(transcriptList.translationLanguages)}`;
    }

    function getLanguageDescription(transcripts) {
        return transcripts.length > 0 ? transcripts.map(t => ` - ${t}`).join('\n') : 'None';
    }

    async function run() {
        const options = parseArguments();
        const output = await fetchAndFormatTranscripts(options);
        console.log(output);
    }

    async function fetchVideoHtml(httpClient, videoId) {
        const response = await httpClient.get(watchURL.replace('{video_id}', videoId), {
            headers: { 'Accept-Language': 'en-US' }
        });
        return unescape(response.data);
    }

    run().catch(err => {
        console.error('An error occurred:', err);
    });
};

export default ytScript;



error.js



import { watchURL } from './settings.js';


function couldNotRetrieveTranscript(videoId) {
    const error = new Error();
    error.videoId = videoId;
    error.message = buildErrorMessage(videoId, error.cause);
    error.name = 'CouldNotRetrieveTranscript';
    return error;
}

function buildErrorMessage(videoId, cause) {
    let errorMessage = `\nCould not retrieve a transcript for the video ${settings.watchURL.replace('{video_id}', videoId)}!`;
    if (cause) {
        errorMessage += ` This is most likely caused by:\n\n${cause}`;
        errorMessage += `\n\nIf you are sure that the described cause is not responsible for this error and that a transcript should be retrievable, please create an issue at https://github.com/jdepoix/youtube-transcript-api/issues. Please add which version of youtube-transcript-api you are using and provide the information needed to replicate the error. Also make sure that there are no open issues which already describe your problem!`;
    }
    return errorMessage;
}

function youTubeRequestFailed(videoId, httpError) {
    const error = createCouldNotRetrieveTranscript(videoId);
    error.reason = httpError.message;
    error.cause = `Request to YouTube failed: ${error.reason}`;
    error.name = 'YouTubeRequestFailed';
    return error;
}

function videoUnavailable(videoId) {
    const error = createCouldNotRetrieveTranscript(videoId);
    error.cause = 'The video is no longer available';
    error.name = 'VideoUnavailable';
    return error;
}

function invalidVideoId(videoId) {
    const error = createCouldNotRetrieveTranscript(videoId);
    error.cause = 'You provided an invalid video id. Make sure you are using the video id and NOT the url!\n\nDo NOT run: `YouTubeTranscriptApi.getTranscript("https://www.youtube.com/watch?v=1234")`\nInstead run: `YouTubeTranscriptApi.getTranscript("1234")`';
    error.name = 'InvalidVideoId';
    return error;
}

function tooManyRequests(videoId) {
    const error = createCouldNotRetrieveTranscript(videoId);
    error.cause = 'YouTube is receiving too many requests from this IP and now requires solving a captcha to continue. One of the following things can be done to work around this:\n- Manually solve the captcha in a browser and export the cookie. Read here how to use that cookie with youtube-transcript-api: https://github.com/jdepoix/youtube-transcript-api#cookies\n- Use a different IP address\n- Wait until the ban on your IP has been lifted';
    error.name = 'TooManyRequests';
    return error;
}

function transcriptsDisabled(videoId) {
    const error = createCouldNotRetrieveTranscript(videoId);
    error.cause = 'Subtitles are disabled for this video';
    error.name = 'TranscriptsDisabled';
    return error;
}

function noTranscriptAvailable(videoId) {
    const error = createCouldNotRetrieveTranscript(videoId);
    error.cause = 'No transcripts are available for this video';
    error.name = 'NoTranscriptAvailable';
    return error;
}

function notTranslatable(videoId) {
    const error = createCouldNotRetrieveTranscript(videoId);
    error.cause = 'The requested language is not translatable';
    error.name = 'NotTranslatable';
    return error;
}

function translationLanguageNotAvailable(videoId) {
    const error = createCouldNotRetrieveTranscript(videoId);
    error.cause = 'The requested translation language is not available';
    error.name = 'TranslationLanguageNotAvailable';
    return error;
}

function cookiePathInvalid(videoId) {
    const error = createCouldNotRetrieveTranscript(videoId);
    error.cause = 'The provided cookie file was unable to be loaded';
    error.name = 'CookiePathInvalid';
    return error;
}

function cookiesInvalid(videoId) {
    const error = createCouldNotRetrieveTranscript(videoId);
    error.cause = 'The cookies provided are not valid (may have expired)';
    error.name = 'CookiesInvalid';
    return error;
}

function failedToCreateConsentCookie(videoId) {
    const error = createCouldNotRetrieveTranscript(videoId);
    error.cause = 'Failed to automatically give consent to saving cookies';
    error.name = 'FailedToCreateConsentCookie';
    return error;
}

function noTranscriptFound(videoId, requestedLanguageCodes, transcriptData) {
    const error = createCouldNotRetrieveTranscript(videoId);
    error._requestedLanguageCodes = requestedLanguageCodes;
    error._transcriptData = transcriptData;
    error.cause = `No transcripts were found for any of the requested language codes: ${requestedLanguageCodes.join(', ')}\n\n${transcriptData}`;
    error.name = 'NoTranscriptFound';
    return error;
}

export {
    couldNotRetrieveTranscript,
    youTubeRequestFailed,
    videoUnavailable,
    invalidVideoId,
    tooManyRequests,
    transcriptsDisabled,
    noTranscriptAvailable,
    notTranslatable,
    translationLanguageNotAvailable,
    cookiePathInvalid,
    cookiesInvalid,
    failedToCreateConsentCookie,
    noTranscriptFound
};



formatter.js



import util from 'util';


function formatPretty(transcript, options = {}) {
    return util.inspect(transcript, { compact: false, ...options });
}

function formatJSON(transcript, options = {}) {
    return JSON.stringify(transcript, null, options.space);
}

function formatPlainText(transcript) {
    return transcript.map(line => line.text).join('\n');
}

function formatPlainTextMultiple(transcripts) {
    return transcripts.map(transcript => formatPlainText(transcript)).join('\n\n\n');
}

function formatTimestamp(seconds, format) {
    const hours = Math.floor(seconds / 3600);
    seconds %= 3600;
    const minutes = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    const milliseconds = Math.round((seconds % 1) * 1000);

    return format(hours, minutes, secs, milliseconds);
}

function getSRTTimestamp(hours, minutes, seconds, milliseconds) {
    return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')},${String(milliseconds).padStart(3, '0')}`;
}

function getWebVTTTimestamp(hours, minutes, seconds, milliseconds) {
    return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(milliseconds).padStart(3, '0')}`;
}

function formatTranscriptHelper(transcript, getTimestampFunc, formatHeaderFunc, formatLineFunc) {
    const lines = transcript.map((line, index) => {
        const end = line.start + line.duration;
        const nextStart = transcript[index + 1]?.start || end;
        const timecode = `${formatTimestamp(line.start, getTimestampFunc)} --> ${formatTimestamp(nextStart, getTimestampFunc)}`;
        return formatLineFunc(index, timecode, line);
    });

    return formatHeaderFunc(lines);
}

function formatSRT(transcript) {
    return formatTranscriptHelper(transcript, getSRTTimestamp, lines => lines.join('\n\n') + '\n', (index, timecode, line) => `${index + 1}\n${timecode}\n${line.text}`);
}

function formatWebVTT(transcript) {
    return formatTranscriptHelper(transcript, getWebVTTTimestamp, lines => `WEBVTT\n\n${lines.join('\n\n')}\n`, (index, timecode, line) => `${timecode}\n${line.text}`);
}

function FormatterFactory(format = 'pretty') {
    const formats = {
        json: formatJSON,
        pretty: formatPretty,
        text: formatPlainText,
        textMultiple: formatPlainTextMultiple,
        webvtt: formatWebVTT,
        srt: formatSRT
    };

    const formatter = formats[format];
    if (!formatter) {
        throw new Error(`The format '${format}' is not supported. Supported formats: ${Object.keys(formats).join(', ')}`);
    }
    return formatter;
}

export {
    formatPretty,
    formatJSON,
    formatPlainText,
    formatPlainTextMultiple,
    formatSRT,
    formatWebVTT,
    FormatterFactory
};



htmlParser.js



import { parse } from 'node-html-parser';


export function parseHtml(string) {
    return parse(string).innerText;
}




settings.js



const watchURL = 'https://www.youtube.com/watch?v={video_id}';

export { watchURL };



transcripts.js



import { DOMParser } from 'xmldom';
import { watchURL} from './settings.js';
import {
    couldNotRetrieveTranscript,
    youTubeRequestFailed,
    videoUnavailable,
    invalidVideoId,
    tooManyRequests,
    transcriptsDisabled,
    noTranscriptAvailable,
    notTranslatable,
    translationLanguageNotAvailable,
    cookiePathInvalid,
    cookiesInvalid,
    failedToCreateConsentCookie,
    noTranscriptFound
} from './error.js';
import { parseHtml } from './htmlParser.js';
import axios from 'axios';
import tough from 'tough-cookie';
import fs from 'fs';


// Fetch video HTML and extract captions JSON
async function fetchVideoHtml(httpClient, videoId) {
    let html = await fetchHtml(httpClient, videoId);
    if (html.includes('action="https://consent.youtube.com/s"')) {
        await createConsentCookie(httpClient, html, videoId);
        html = await fetchHtml(httpClient, videoId);
        if (html.includes('action="https://consent.youtube.com/s"')) {
            throw new errors.FailedToCreateConsentCookie(videoId);
        }
    }
    return html;
}

async function fetchHtml(httpClient, videoId) {
    const response = await httpClient.get(settings.watchURL.replace('{video_id}', videoId), {
        headers: { 'Accept-Language': 'en-US' }
    });
    return unescape(response.data);
}

async function createConsentCookie(httpClient, html, videoId) {
    const match = html.match(/name="v" value="(.*?)"/);
    if (!match) {
        throw new errors.FailedToCreateConsentCookie(videoId);
    }
    httpClient.defaults.jar.setCookieSync(`CONSENT=YES+${match[1]}`, 'https://www.youtube.com');
}

function extractCaptionsJson(html, videoId) {
    const splittedHtml = html.split('"captions":');

    if (splittedHtml.length <= 1) {
        if (videoId.startsWith('http://') || videoId.startsWith('https://')) {
            throw new errors.InvalidVideoId(videoId);
        }
        if (html.includes('class="g-recaptcha"')) {
            throw new errors.TooManyRequests(videoId);
        }
        if (!html.includes('"playabilityStatus":')) {
            throw new errors.VideoUnavailable(videoId);
        }
        throw new errors.TranscriptsDisabled(videoId);
    }

    const captionsJson = JSON.parse(
        splittedHtml[1].split(',"videoDetails')[0].replace('\n', '')
    ).playerCaptionsTracklistRenderer;

    if (!captionsJson) {
        throw new errors.TranscriptsDisabled(videoId);
    }

    if (!captionsJson.captionTracks) {
        throw new errors.NoTranscriptAvailable(videoId);
    }

    return captionsJson;
}

// Build transcript list
function buildTranscriptList(httpClient, videoId, captionsJson) {
    const translationLanguages = captionsJson.translationLanguages.map(lang => ({
        language: lang.languageName.simpleText,
        language_code: lang.languageCode
    }));

    const manuallyCreatedTranscripts = {};
    const generatedTranscripts = {};

    captionsJson.captionTracks.forEach(caption => {
        const transcriptDict = caption.kind === 'asr' ? generatedTranscripts : manuallyCreatedTranscripts;
        transcriptDict[caption.languageCode] = createTranscript(
            httpClient,
            videoId,
            caption.baseUrl,
            caption.name.simpleText,
            caption.languageCode,
            caption.kind === 'asr',
            caption.isTranslatable ? translationLanguages : []
        );
    });

    return {
        videoId,
        manuallyCreatedTranscripts,
        generatedTranscripts,
        translationLanguages
    };
}

function* transcriptListIterator(manuallyCreatedTranscripts, generatedTranscripts) {
    yield* Object.values(manuallyCreatedTranscripts);
    yield* Object.values(generatedTranscripts);
}

function findTranscript(transcriptList, languageCodes) {
    return findTranscriptHelper(transcriptList, languageCodes, [transcriptList.manuallyCreatedTranscripts, transcriptList.generatedTranscripts]);
}

function findGeneratedTranscript(transcriptList, languageCodes) {
    return findTranscriptHelper(transcriptList, languageCodes, [transcriptList.generatedTranscripts]);
}

function findManuallyCreatedTranscript(transcriptList, languageCodes) {
    return findTranscriptHelper(transcriptList, languageCodes, [transcriptList.manuallyCreatedTranscripts]);
}

function findTranscriptHelper(transcriptList, languageCodes, transcriptDicts) {
    for (const code of languageCodes) {
        for (const dict of transcriptDicts) {
            if (dict[code]) {
                return dict[code];
            }
        }
    }
    throw new errors.NoTranscriptFound(transcriptList.videoId, languageCodes);
}

function transcriptListToString(transcriptList) {
    return `For this video (${transcriptList.videoId}) transcripts are available in the following languages:\n\n(MANUALLY CREATED)\n${getLanguageDescription(Object.values(transcriptList.manuallyCreatedTranscripts))}\n\n(GENERATED)\n${getLanguageDescription(Object.values(transcriptList.generatedTranscripts))}\n\n(TRANSLATION LANGUAGES)\n${getLanguageDescription(transcriptList.translationLanguages)}`;
}

function getLanguageDescription(transcripts) {
    return transcripts.length > 0 ? transcripts.map(t => ` - ${t}`).join('\n') : 'None';
}

// Transcript creation
function createTranscript(httpClient, videoId, url, language, languageCode, isGenerated, translationLanguages) {
    const translationLanguagesDict = translationLanguages.reduce((acc, lang) => {
        acc[lang.language_code] = lang.language;
        return acc;
    }, {});

    return {
        httpClient,
        videoId,
        url,
        language,
        languageCode,
        isGenerated,
        translationLanguages,
        translationLanguagesDict,
        async fetch(preserveFormatting = false) {
            const response = await httpClient.get(url, {
                headers: { 'Accept-Language': 'en-US' }
            });
            const parser = createTranscriptParser(preserveFormatting);
            return parser.parse(unescape(response.data));
        },
        toString() {
            return `${languageCode} ("${language}")${this.isTranslatable ? '[TRANSLATABLE]' : ''}`;
        },
        get isTranslatable() {
            return this.translationLanguages.length > 0;
        },
        async translate(languageCode) {
            if (!this.isTranslatable) {
                throw new errors.NotTranslatable(this.videoId);
            }
            if (!this.translationLanguagesDict[languageCode]) {
                throw new errors.TranslationLanguageNotAvailable(this.videoId);
            }
            return createTranscript(
                httpClient,
                videoId,
                `${url}&tlang=${languageCode}`,
                this.translationLanguagesDict[languageCode],
                languageCode,
                true,
                []
            );
        }
    };
}

// Transcript parser
function createTranscriptParser(preserveFormatting = false) {
    const htmlRegex = getHtmlRegex(preserveFormatting);
    return {
        parse(plainData) {
            const doc = new DOMParser().parseFromString(plainData, 'text/xml');
            return Array.from(doc.documentElement.getElementsByTagName('text')).map(el => ({
                text: el.textContent,
                start: parseFloat(el.getAttribute('start')),
                duration: parseFloat(el.getAttribute('dur') || '0.0')
            }));
        }
    };

    function getHtmlRegex(preserveFormatting) {
        if (preserveFormatting) {
            const formattingTags = ['strong', 'em', 'b', 'i', 'mark', 'small', 'del', 'ins', 'sub', 'sup'].join('|');
            return new RegExp(`<\/?(?!\/?(${formattingTags})\b).*?\b>`, 'gi');
        } else {
            return /<[^>]*>/gi;
        }
    }
}

export {
    fetchVideoHtml,
    fetchHtml,
    createConsentCookie,
    extractCaptionsJson,
    buildTranscriptList,
    transcriptListIterator,
    findTranscript,
    findGeneratedTranscript,
    findManuallyCreatedTranscript,
    transcriptListToString,
    createTranscript,
    createTranscriptParser
};



